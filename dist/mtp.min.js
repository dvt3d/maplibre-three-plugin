(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // globals:three
  var require_three = __commonJS({
    "globals:three"(exports, module) {
      module.exports = THREE;
    }
  });

  // src/modules/scene/MapScene.js
  var import_three3 = __toESM(require_three(), 1);

  // src/modules/constants/index.js
  var WORLD_SIZE = 512 * 2e3;
  var EARTH_RADIUS = 63710088e-1;
  var EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  var PROJECTION_WORLD_SIZE = WORLD_SIZE / EARTH_CIRCUMFERENCE;
  var TILE_SIZE = 512;

  // src/modules/utils/Util.js
  var Util = class {
    /**
     *
     * @param n
     * @param min
     * @param max
     * @returns {number}
     */
    static clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }
    /**
     *
     * @param fovy
     * @param aspect
     * @param near
     * @param far
     * @returns {number[]}
     */
    static makePerspectiveMatrix(fovy, aspect, near, far) {
      let f = 1 / Math.tan(fovy / 2);
      let nf = 1 / (near - far);
      return [
        f / aspect,
        0,
        0,
        0,
        0,
        f,
        0,
        0,
        0,
        0,
        (far + near) * nf,
        -1,
        0,
        0,
        2 * far * near * nf,
        0
      ];
    }
    /**
     *
     * @param lng
     * @returns {number}
     */
    static mercatorXFromLng(lng) {
      return (180 + lng) / 360;
    }
    /**
     *
     * @param lat
     * @returns {number}
     */
    static mercatorYFromLat(lat) {
      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
    }
    /**
     *
     * @param map
     * @param center
     * @param boundingSize
     * @returns {{center: (number|*)[], cameraHeight: number, zoom: number}}
     */
    static getViewInfo(transform, center, boundingSize) {
      const fovInRadians = transform.fov * DEG2RAD;
      const pitchInRadians = transform.pitch * DEG2RAD;
      if (Array.isArray(center)) {
        center = { lng: center[0], lat: center[1], alt: center[2] || 0 };
      }
      if (typeof center === "string") {
        let arr = center.split(",");
        center = { lng: arr[0], lat: arr[1], alt: arr[2] || 0 };
      }
      const distance = Math.max(boundingSize.x, boundingSize.y, boundingSize.z) / (2 * Math.tan(fovInRadians / 2));
      const cameraHeight = distance * Math.cos(pitchInRadians) + center.alt;
      const pixelAltitude = Math.abs(
        Math.cos(pitchInRadians) * transform.cameraToCenterDistance
      );
      const metersInWorldAtLat = EARTH_CIRCUMFERENCE * Math.abs(Math.cos(center.lat * DEG2RAD));
      const worldSize = pixelAltitude / cameraHeight * metersInWorldAtLat;
      const zoom = Math.round(Math.log(worldSize / transform.tileSize) / Math.LN2);
      return {
        center: [center.lng, center.lat],
        cameraHeight,
        zoom
      };
    }
  };
  var Util_default = Util;

  // src/modules/camera/CameraSync.js
  var import_three = __toESM(require_three(), 1);
  var projectionMatrix = new import_three.Matrix4();
  var cameraTranslateZ = new import_three.Matrix4();
  var MAX_VALID_LATITUDE = 85.051129;
  var CameraSync = class {
    constructor(map, world, camera) {
      this._map = map;
      this._world = world;
      this._camera = camera;
      this._translateCenter = new import_three.Matrix4().makeTranslation(
        WORLD_SIZE / 2,
        -WORLD_SIZE / 2,
        0
      );
      this._worldSizeRatio = TILE_SIZE / WORLD_SIZE;
      this._map.on("move", this.syncCamera.bind(this));
      this._map.on("resize", this.syncCamera.bind(this));
    }
    /**
     *
     */
    syncCamera() {
      const transform = this._map.transform;
      this._camera.aspect = transform.width / transform.height;
      const centerOffset = transform.centerOffset || new import_three.Vector3();
      const fovInRadians = transform.fov * DEG2RAD;
      const pitchInRadians = transform.pitch * DEG2RAD;
      const bearingInRadians = transform.bearing * DEG2RAD;
      projectionMatrix.elements = Util_default.makePerspectiveMatrix(
        fovInRadians,
        this._camera.aspect,
        transform.height / 50,
        transform.farZ
      );
      this._camera.projectionMatrix = projectionMatrix;
      this._camera.projectionMatrix.elements[8] = -centerOffset.x * 2 / transform.width;
      this._camera.projectionMatrix.elements[9] = centerOffset.y * 2 / transform.height;
      cameraTranslateZ.makeTranslation(0, 0, transform.cameraToCenterDistance);
      const cameraWorldMatrix = new import_three.Matrix4().premultiply(cameraTranslateZ).premultiply(new import_three.Matrix4().makeRotationX(pitchInRadians)).premultiply(new import_three.Matrix4().makeRotationZ(-bearingInRadians));
      if (transform.elevation) {
        cameraWorldMatrix.elements[14] = transform.cameraToCenterDistance * Math.cos(pitchInRadians);
      }
      this._camera.matrixWorld.copy(cameraWorldMatrix);
      const zoomPow = transform.scale * this._worldSizeRatio;
      const scale = new import_three.Matrix4().makeScale(zoomPow, zoomPow, zoomPow);
      let x = transform.x;
      let y = transform.y;
      if (!x || !y) {
        const center = transform.center;
        const lat = Util_default.clamp(
          center.lat,
          -MAX_VALID_LATITUDE,
          MAX_VALID_LATITUDE
        );
        x = Util_default.mercatorXFromLng(center.lng) * transform.worldSize;
        y = Util_default.mercatorYFromLat(lat) * transform.worldSize;
      }
      const translateMap = new import_three.Matrix4().makeTranslation(-x, y, 0);
      const rotateMap = new import_three.Matrix4().makeRotationZ(Math.PI);
      this._world.matrix = new import_three.Matrix4().premultiply(rotateMap).premultiply(this._translateCenter).premultiply(scale).premultiply(translateMap);
    }
  };
  var CameraSync_default = CameraSync;

  // src/modules/layer/ThreeLayer.js
  var ThreeLayer = class {
    constructor(id, mapScene) {
      this._id = id;
      this._mapScene = mapScene;
      this._cameraSync = new CameraSync_default(
        this._mapScene.map,
        this._mapScene.world,
        this._mapScene.camera
      );
    }
    get id() {
      return this._id;
    }
    get type() {
      return "custom";
    }
    get renderingMode() {
      return "3d";
    }
    onAdd(map, gl) {
      this._cameraSync.syncCamera();
    }
    render() {
      this._mapScene.render();
    }
  };
  var ThreeLayer_default = ThreeLayer;

  // src/modules/transform/SceneTransform.js
  var import_three2 = __toESM(require_three(), 1);
  var SceneTransform = class {
    /**
     *
     * @returns {number}
     */
    static projectedMercatorUnitsPerMeter() {
      return Math.abs(WORLD_SIZE / EARTH_CIRCUMFERENCE);
    }
    /**
     *
     * @param lat
     * @returns {number}
     */
    static projectedUnitsPerMeter(lat) {
      return Math.abs(WORLD_SIZE / Math.cos(DEG2RAD * lat) / EARTH_CIRCUMFERENCE);
    }
    /**
     *
     * @param lng
     * @param lat
     * @param alt
     * @returns {Vector3}
     */
    static lngLatToVector3(lng, lat, alt = 0) {
      let v = [0, 0, 0];
      if (Array.isArray(lng)) {
        v = [
          -EARTH_RADIUS * DEG2RAD * lng[0] * PROJECTION_WORLD_SIZE,
          -EARTH_RADIUS * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * DEG2RAD * lng[1])) * PROJECTION_WORLD_SIZE
        ];
        if (!lng[2]) {
          v.push(0);
        } else {
          v.push(lng[2] * this.projectedUnitsPerMeter(lng[1]));
        }
      } else {
        v = [
          -EARTH_RADIUS * DEG2RAD * lng * PROJECTION_WORLD_SIZE,
          -EARTH_RADIUS * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * DEG2RAD * lat)) * PROJECTION_WORLD_SIZE
        ];
        if (!alt) {
          v.push(0);
        } else {
          v.push(alt * this.projectedUnitsPerMeter(lat));
        }
      }
      return new import_three2.Vector3(v[0], v[1], v[2]);
    }
    /**
     *
     * @param v
     * @returns {{lng: number, alt: number, lat: number}}
     */
    static vector3ToLngLat(v) {
      let result = [0, 0, 0];
      if (v) {
        result[0] = -v.x / (EARTH_RADIUS * DEG2RAD * PROJECTION_WORLD_SIZE);
        result[1] = 2 * (Math.atan(Math.exp(v.y / (PROJECTION_WORLD_SIZE * -EARTH_RADIUS))) - Math.PI / 4) / DEG2RAD;
        result[2] = v.z / this.projectedUnitsPerMeter(result[1]);
      }
      return result;
    }
  };
  var SceneTransform_default = SceneTransform;

  // src/modules/scene/MapScene.js
  var DEF_OPTS = {
    scene: null,
    camera: null,
    renderer: null,
    renderLoop: null,
    preserveDrawingBuffer: false
  };
  var MapScene = class {
    constructor(map, options = {}) {
      if (!map) {
        throw "missing  map";
      }
      this._map = map;
      this._options = {
        ...DEF_OPTS,
        ...options
      };
      this._canvas = map.getCanvas();
      this._scene = this._options.scene || new import_three3.Scene();
      this._camera = this._options.camera || new import_three3.PerspectiveCamera(
        this._map.transform.fov,
        this._map.transform.width / this._map.transform.height,
        0.1,
        1e21
      );
      this._camera.matrixAutoUpdate = false;
      this._renderer = this._options.renderer || new import_three3.WebGLRenderer({
        alpha: true,
        antialias: true,
        preserveDrawingBuffer: this._options.preserveDrawingBuffer,
        canvas: this._canvas,
        context: this._canvas.getContext("webgl2")
      });
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._renderer.setSize(this._canvas.clientWidth, this._canvas.clientHeight);
      this._renderer.autoClear = false;
      this._lights = new import_three3.Group();
      this._lights.name = "lights";
      this._scene.add(this._lights);
      this._world = new import_three3.Group();
      this._world.name = "world";
      this._world.userData = {
        isWorld: true,
        name: "world"
      };
      this._world.position.set(WORLD_SIZE / 2, WORLD_SIZE / 2, 0);
      this._world.matrixAutoUpdate = false;
      this._scene.add(this._world);
      this._map.on("style.load", this._onStyleLoad.bind(this));
      this._event = new import_three3.EventDispatcher();
    }
    get map() {
      return this._map;
    }
    get canvas() {
      return this._canvas;
    }
    get camera() {
      return this._camera;
    }
    get scene() {
      return this._scene;
    }
    get lights() {
      return this._lights;
    }
    get world() {
      return this._world;
    }
    get renderer() {
      return this._renderer;
    }
    /**
     *
     * @private
     */
    _onStyleLoad() {
      this._map.addLayer(new ThreeLayer_default("map_scene_layer", this));
    }
    /**
     *
     * @returns {MapScene}
     */
    render() {
      if (this._options.renderLoop) {
        this._options.renderLoop(this);
      } else {
        this._event.dispatchEvent({
          type: "preRest"
        });
        this.renderer.resetState();
        this._event.dispatchEvent({
          type: "postRest"
        });
        this._event.dispatchEvent({
          type: "preRender"
        });
        this.renderer.render(this._scene, this._camera);
        this._event.dispatchEvent({
          type: "postRender"
        });
      }
      return this;
    }
    /**
     *
     * @param light
     * @returns {MapScene}
     */
    addLight(light) {
      this._lights.add(light.delegate || light);
      return this;
    }
    /**
     *
     * @param light
     */
    removeLight(light) {
      this._lights.remove(light.delegate || light);
      return this;
    }
    /**
     *
     * @param object
     * @returns {MapScene}
     */
    addObject(object) {
      this._world.add(object.delegate || object);
      return this;
    }
    /**
     *
     * @param object
     * @returns {MapScene}
     */
    removeObject(object) {
      this._world.remove(object);
      object.traverse((child) => {
        if (child.geometry)
          child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((m) => m.dispose());
          } else {
            child.material.dispose();
          }
        }
        if (child.texture)
          child.texture.dispose();
      });
      return this;
    }
    /**
     *
     * @param target
     * @param completed
     * @param duration
     * @returns {MapScene}
     */
    flyTo(target, completed = null, duration = 3) {
      if (target && target.position) {
        if (completed) {
          this._map.once("moveend", completed);
        }
        let size = target.size;
        if (!size) {
          size = new import_three3.Vector3();
          new import_three3.Box3().setFromObject(target.delegate || target, true).getSize(size);
        }
        const viewInfo = Util_default.getViewInfo(
          this._map.transform,
          SceneTransform_default.vector3ToLngLat(target.position),
          size
        );
        this._map.flyTo({
          center: viewInfo.center,
          zoom: viewInfo.zoom,
          duration: duration * 1e3
        });
      }
      return this;
    }
    /**
     *
     * @param target
     * @param completed
     * @returns {MapScene}
     */
    zoomTo(target, completed) {
      return this.flyTo(target, completed, 0);
    }
    /**
     *
     * @param type
     * @param callback
     * @returns {MapScene}
     */
    on(type, callback) {
      this._event.addEventListener(type, callback);
      return this;
    }
    /**
     *
     * @param type
     * @param callback
     * @returns {MapScene}
     */
    off(type, callback) {
      this._event.removeEventListener(type, callback);
      return this;
    }
  };
  var MapScene_default = MapScene;

  // src/modules/sun/Sun.js
  var import_three4 = __toESM(require_three(), 1);

  // src/modules/utils/SunCalc.js
  var PI = Math.PI;
  var sin = Math.sin;
  var cos = Math.cos;
  var tan = Math.tan;
  var asin = Math.asin;
  var atan = Math.atan2;
  var acos = Math.acos;
  var rad = PI / 180;
  var dayMs = 1e3 * 60 * 60 * 24;
  var J1970 = 2440588;
  var J2000 = 2451545;
  function toJulian(date) {
    return date.valueOf() / dayMs - 0.5 + J1970;
  }
  function fromJulian(j) {
    return new Date((j + 0.5 - J1970) * dayMs);
  }
  function toDays(date) {
    return toJulian(date) - J2000;
  }
  var e = rad * 23.4397;
  function rightAscension(l, b) {
    return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
  }
  function declination(l, b) {
    return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
  }
  function azimuth(H, phi, dec) {
    return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
  }
  function altitude(H, phi, dec) {
    return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
  }
  function siderealTime(d, lw) {
    return rad * (280.16 + 360.9856235 * d) - lw;
  }
  function astroRefraction(h) {
    if (h < 0)
      h = 0;
    return 2967e-7 / Math.tan(h + 312536e-8 / (h + 0.08901179));
  }
  function solarMeanAnomaly(d) {
    return rad * (357.5291 + 0.98560028 * d);
  }
  function eclipticLongitude(M) {
    let C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 3e-4 * sin(3 * M)), P = rad * 102.9372;
    return M + C + P + PI;
  }
  function sunCoords(d) {
    let M = solarMeanAnomaly(d), L = eclipticLongitude(M);
    return {
      dec: declination(L, 0),
      ra: rightAscension(L, 0)
    };
  }
  var SunCalc = {};
  SunCalc.getPosition = function(date, lat, lng) {
    let lw = rad * -lng, phi = rad * lat, d = toDays(date), c = sunCoords(d), H = siderealTime(d, lw) - c.ra;
    return {
      azimuth: azimuth(H, phi, c.dec),
      altitude: altitude(H, phi, c.dec)
    };
  };
  var times = SunCalc.times = [
    [-0.833, "sunrise", "sunset"],
    [-0.3, "sunriseEnd", "sunsetStart"],
    [-6, "dawn", "dusk"],
    [-12, "nauticalDawn", "nauticalDusk"],
    [-18, "nightEnd", "night"],
    [6, "goldenHourEnd", "goldenHour"]
  ];
  SunCalc.addTime = function(angle, riseName, setName) {
    times.push([angle, riseName, setName]);
  };
  var J0 = 9e-4;
  function julianCycle(d, lw) {
    return Math.round(d - J0 - lw / (2 * PI));
  }
  function approxTransit(Ht, lw, n) {
    return J0 + (Ht + lw) / (2 * PI) + n;
  }
  function solarTransitJ(ds, M, L) {
    return J2000 + ds + 53e-4 * sin(M) - 69e-4 * sin(2 * L);
  }
  function hourAngle(h, phi, d) {
    return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d)));
  }
  function observerAngle(height) {
    return -2.076 * Math.sqrt(height) / 60;
  }
  function getSetJ(h, lw, phi, dec, n, M, L) {
    let w = hourAngle(h, phi, dec), a = approxTransit(w, lw, n);
    return solarTransitJ(a, M, L);
  }
  SunCalc.getTimes = function(date, lat, lng, height) {
    height = height || 0;
    let lw = rad * -lng, phi = rad * lat, dh = observerAngle(height), d = toDays(date), n = julianCycle(d, lw), ds = approxTransit(0, lw, n), M = solarMeanAnomaly(ds), L = eclipticLongitude(M), dec = declination(L, 0), Jnoon = solarTransitJ(ds, M, L), i, len, time, h0, Jset, Jrise;
    let result = {
      solarNoon: fromJulian(Jnoon),
      nadir: fromJulian(Jnoon - 0.5)
    };
    for (i = 0, len = times.length; i < len; i += 1) {
      time = times[i];
      h0 = (time[0] + dh) * rad;
      Jset = getSetJ(h0, lw, phi, dec, n, M, L);
      Jrise = Jnoon - (Jset - Jnoon);
      result[time[1]] = fromJulian(Jrise);
      result[time[2]] = fromJulian(Jset);
    }
    return result;
  };
  function moonCoords(d) {
    let L = rad * (218.316 + 13.176396 * d), M = rad * (134.963 + 13.064993 * d), F = rad * (93.272 + 13.22935 * d), l = L + rad * 6.289 * sin(M), b = rad * 5.128 * sin(F), dt = 385001 - 20905 * cos(M);
    return {
      ra: rightAscension(l, b),
      dec: declination(l, b),
      dist: dt
    };
  }
  SunCalc.getMoonPosition = function(date, lat, lng) {
    let lw = rad * -lng, phi = rad * lat, d = toDays(date), c = moonCoords(d), H = siderealTime(d, lw) - c.ra, h = altitude(H, phi, c.dec), pa = atan(sin(H), tan(phi) * cos(c.dec) - sin(c.dec) * cos(H));
    h = h + astroRefraction(h);
    return {
      azimuth: azimuth(H, phi, c.dec),
      altitude: h,
      distance: c.dist,
      parallacticAngle: pa
    };
  };
  SunCalc.getMoonIllumination = function(date) {
    let d = toDays(date || /* @__PURE__ */ new Date()), s = sunCoords(d), m = moonCoords(d), sdist = 149598e3, phi = acos(
      sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)
    ), inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi)), angle = atan(
      cos(s.dec) * sin(s.ra - m.ra),
      sin(s.dec) * cos(m.dec) - cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra)
    );
    return {
      fraction: (1 + cos(inc)) / 2,
      phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI,
      angle
    };
  };
  function hoursLater(date, h) {
    return new Date(date.valueOf() + h * dayMs / 24);
  }
  SunCalc.getMoonTimes = function(date, lat, lng, inUTC) {
    let t = new Date(date);
    if (inUTC)
      t.setUTCHours(0, 0, 0, 0);
    else
      t.setHours(0, 0, 0, 0);
    let hc = 0.133 * rad, h0 = SunCalc.getMoonPosition(t, lat, lng).altitude - hc, h1, h2, rise, set, a, b, xe, ye, d, roots, x1, x2, dx;
    for (let i = 1; i <= 24; i += 2) {
      h1 = SunCalc.getMoonPosition(hoursLater(t, i), lat, lng).altitude - hc;
      h2 = SunCalc.getMoonPosition(hoursLater(t, i + 1), lat, lng).altitude - hc;
      a = (h0 + h2) / 2 - h1;
      b = (h2 - h0) / 2;
      xe = -b / (2 * a);
      ye = (a * xe + b) * xe + h1;
      d = b * b - 4 * a * h1;
      roots = 0;
      if (d >= 0) {
        dx = Math.sqrt(d) / (Math.abs(a) * 2);
        x1 = xe - dx;
        x2 = xe + dx;
        if (Math.abs(x1) <= 1)
          roots++;
        if (Math.abs(x2) <= 1)
          roots++;
        if (x1 < -1)
          x1 = x2;
      }
      if (roots === 1) {
        if (h0 < 0)
          rise = i + x1;
        else
          set = i + x1;
      } else if (roots === 2) {
        rise = i + (ye < 0 ? x2 : x1);
        set = i + (ye < 0 ? x1 : x2);
      }
      if (rise && set)
        break;
      h0 = h2;
    }
    let result = {};
    if (rise)
      result.rise = hoursLater(t, rise);
    if (set)
      result.set = hoursLater(t, set);
    if (!rise && !set)
      result[ye > 0 ? "alwaysUp" : "alwaysDown"] = true;
    return result;
  };
  var SunCalc_default = SunCalc;

  // src/modules/sun/Sun.js
  var Sun = class {
    constructor() {
      this._delegate = new import_three4.Group();
      this._delegate.name = "Sun";
      this._sunLight = new import_three4.DirectionalLight(16777215, 1);
      this._hemiLight = new import_three4.HemisphereLight(
        new import_three4.Color(16777215),
        new import_three4.Color(16777215),
        0.6
      );
      this._hemiLight.color.setHSL(0.661, 0.96, 0.12);
      this._hemiLight.groundColor.setHSL(0.11, 0.96, 0.14);
      this._hemiLight.position.set(0, 0, 50);
      this._delegate.add(this._sunLight);
      this._delegate.add(this._hemiLight);
      this._currentTime = null;
    }
    get delegate() {
      return this._delegate;
    }
    set castShadow(castShadow) {
      this._sunLight.castShadow = castShadow;
    }
    get castShadow() {
      return this._sunLight.castShadow;
    }
    set currentTime(currentTime) {
      this._currentTime = currentTime;
    }
    get sunLight() {
      return this._sunLight;
    }
    get hemiLight() {
      return this._hemiLight;
    }
    /**
     *
     * @param shadow
     * @returns {Sun}
     */
    setShadow(shadow = {}) {
      this._sunLight.shadow.radius = shadow.radius || 2;
      this._sunLight.shadow.mapSize.width = shadow.mapSize ? shadow.mapSize[0] : 8192;
      this._sunLight.shadow.mapSize.height = shadow.mapSize ? shadow.mapSize[1] : 8192;
      this._sunLight.shadow.camera.top = this._sunLight.shadow.camera.right = shadow.topRight || 1e3;
      this._sunLight.shadow.camera.bottom = this._sunLight.shadow.camera.left = shadow.bottomLeft || -1e3;
      this._sunLight.shadow.camera.near = shadow.near || 1;
      this._sunLight.shadow.camera.far = shadow.far || 1e8;
      this._sunLight.shadow.camera.visible = true;
      return this;
    }
    /**
     *
     * @param frameState
     */
    update(frameState) {
      const WORLD_SIZE2 = 512 * 2e3;
      const date = new Date(this._currentTime || (/* @__PURE__ */ new Date()).getTime());
      const center = frameState.center;
      const sunPosition = SunCalc_default.getPosition(date, center.lat, center.lng);
      const altitude2 = sunPosition.altitude;
      const azimuth2 = Math.PI + sunPosition.azimuth;
      const radius = WORLD_SIZE2 / 2;
      const alt = Math.sin(altitude2);
      const altRadius = Math.cos(altitude2);
      const azCos = Math.cos(azimuth2) * altRadius;
      const azSin = Math.sin(azimuth2) * altRadius;
      this._sunLight.position.set(azSin, azCos, alt);
      this._sunLight.position.multiplyScalar(radius);
      this._sunLight.intensity = Math.max(alt, 0);
      this._hemiLight.intensity = Math.max(alt * 1, 0.1);
      this._sunLight.updateMatrixWorld();
    }
  };
  var Sun_default = Sun;

  // src/modules/creator/Creator.js
  var import_three5 = __toESM(require_three(), 1);
  var Creator = class {
    /**
     *
     * @param center
     * @param rotation
     * @param scale
     */
    static createRTCGroup(center, rotation, scale) {
      const group = new import_three5.Group();
      group.name = "rtc";
      group.position.copy(SceneTransform_default.lngLatToVector3(center));
      if (rotation) {
        group.rotateX(rotation[0] || 0);
        group.rotateY(rotation[1] || 0);
        group.rotateZ(rotation[2] || 0);
      } else {
        group.rotateX(Math.PI / 2);
        group.rotateY(Math.PI);
      }
      if (scale) {
        group.scale.set(scale[0] || 1, scale[1] || 1, scale[2] || 1);
      } else {
        let lat_scale = 1;
        if (Array.isArray(center)) {
          lat_scale = SceneTransform_default.projectedUnitsPerMeter(center[1]);
        } else if (typeof center === "string") {
          lat_scale = SceneTransform_default.projectedUnitsPerMeter(center.split(",")[1]);
        }
        group.scale.set(lat_scale, lat_scale, lat_scale);
      }
      return group;
    }
    /**
     *
     * @param center
     * @param rotation
     * @param scale
     */
    static createMercatorRTCGroup(center, rotation, scale) {
      const group = this.createRTCGroup(center, rotation, scale);
      if (!scale) {
        let lat_scale = 1;
        let mercator_scale = SceneTransform_default.projectedMercatorUnitsPerMeter();
        if (Array.isArray(center)) {
          lat_scale = SceneTransform_default.projectedUnitsPerMeter(center[1]);
        } else if (typeof center === "string") {
          lat_scale = SceneTransform_default.projectedUnitsPerMeter(center.split(",")[1]);
        }
        group.scale.set(mercator_scale, mercator_scale, lat_scale);
      }
      return group;
    }
    /**
     *
     * @param center
     * @param width
     * @param height
     * @returns {Mesh}
     */
    static createShadowGround(center, width = 100, height = 100) {
      const geo = new import_three5.PlaneGeometry(width, height);
      const mat = new import_three5.ShadowMaterial({
        opacity: 0.5,
        transparent: true
      });
      let mesh = new import_three5.Mesh(geo, mat);
      mesh.position.copy(SceneTransform_default.lngLatToVector3(center));
      mesh.receiveShadow = true;
      mesh.name = "shadow-ground";
      return mesh;
    }
  };
  var Creator_default = Creator;
})();
