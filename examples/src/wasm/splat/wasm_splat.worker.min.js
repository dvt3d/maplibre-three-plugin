import s,{process_splats_from_buffer as t,append_data_from_buffer as e,process_splats_from_geometry as r,process_splats_from_spz as o,sort_splats as u,compute_bounds as a,unregister_positions as f}from"./wasm_splat.min.js";let n=!1,c=null;const _={};function i(s){return{outCS:new Float32Array(new ArrayBuffer(4*s*4)),outRC:new Uint32Array(new ArrayBuffer(4*s*4))}}self.onmessage=async d=>{const{id:l,fn:p,args:m}=d.data;try{let d;if("__init_wasm__"===p)return n||(await s(),n=!0),void postMessage({id:l,result:!0});if(n||(c||(c=s().then(()=>(n=!0,!0)).catch(s=>{throw n=!1,c=null,s})),await c),"process_splats_from_buffer"===p){const[s,e,r]=m,o=new Uint8Array(e),{outCS:u,outRC:a}=i(r),f=t(o,r,u,a);_[s]={bufferId:f},d={meshId:s,out_cs:u,out_rc:a}}else if("append_data_from_buffer"===p){const[s,t,r]=m,{bufferId:o}=_[s],u=new Uint8Array(t),{outCS:a,outRC:f}=i(r);e(o,u,r,a,f),d={out_cs:a,out_rc:f}}else if("process_splats_from_geometry"===p){const[s,t,e,o,u,a]=m,{outCS:f,outRC:n}=i(a),c=r(t,e,o,u,a,f,n);_[s]={bufferId:c},d={meshId:s,out_cs:f,out_rc:n}}else if("process_splats_from_spz"===p){const[s,t,e,r,u,a,f]=m,{outCS:n,outRC:c}=i(f),l=o(t,e,r,u,a,f,n,c);_[s]={bufferId:l},d={meshId:s,out_cs:n,out_rc:c}}else if("sort_splats"===p){const[s,t,e]=m,{bufferId:r}=_[s];d={meshId:s,data:u(r,t,e)}}else if("compute_bounds"===p){const[s]=m,{bufferId:t}=_[s];d={meshId:s,data:a(t)}}else if("unregister_positions"===p){const[s]=m;f(s),d=!0}d instanceof Uint32Array?postMessage({id:l,result:d},[d.buffer]):d?.data?postMessage({id:l,result:d},[d.data.buffer]):d?.out_cs&&d?.out_rc?postMessage({id:l,result:d},[d.out_cs.buffer,d.out_rc.buffer]):postMessage({id:l,result:d})}catch(s){console.error(s),postMessage({id:l,error:s?.message||String(s)})}};